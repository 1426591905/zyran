# 浏览器原理篇

## 浏览器垃圾回收机制 - V8的垃圾回收机制是怎样的
#### 类型：`基础`
#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`
#### 解答（3 分）：
- **1：** V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。
- **1：**（1）新生代算法 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。
- **1：**（2）老生代算法 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。

## 哪些操作会造成内存泄漏？
#### 类型：`基础`
#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`
#### 解答（4 分）：
- **1：** 第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。
- **1：** 第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。
- **1：** 第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。
- **1：** 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。

## 浏览器的渲染过程
#### 类型：`基础`
#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`
#### 解答（5 分）：
- **1：** 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。
- **1：** 然后对 CSS 进行解析，生成 CSSOM 规则树。
- **1：** 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。
- **1：** 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。
- **1：** 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。

## 对Service Worker的理解
#### 类型：`架构`
#### 级别：`W4`、`W5`、`W6`
#### 解答（5 分）：
- **1：** Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。
- **4：** 
    - 首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件
    - 那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存
    - 存在缓存的话就可以直接读取缓存文件，否则就去请求数据。
    - 打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存

## 协商缓存和强缓存的区别
#### 类型：`业务`
#### 级别：`W3`、`W4`、`W5`、`W6`
#### 解答（4 分）：
- **2：** 强缓存
    - 使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。
    - 设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。
- **2：** 协商缓存
    - 如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。
    - 设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。

## 什么情况会阻塞渲染
#### 类型：`基础`
#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`
#### 解答（5 分）：

- **1：** 首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。

- **4：** 
    - 当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。
    - 如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。
    - script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。
    - 对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。