<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.CfHBCVxN.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.D8pQ-J4F.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.DrFaEkyl.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.Dvg3AjVP.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/markdownDialog.CjzyDsWZ.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-level_W2.md.BKzf8iR1.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-level/w1.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>面试级别</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W1.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W1</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W2.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W2</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W3.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W3</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W4.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W4</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W5.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W5</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W6.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W6</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-level_W2" data-v-e6f2a212><div><!----><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">44. 在React中如何避免不必要的render？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>React 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。这里提下优化的点</p>
<ul>
<li>shouldComponentUpdate 和 PureComponent</li>
</ul>
<p>在 React 类组件中，可以利用 shouldComponentUpdate或者 PureComponent 来减少因父组件更新而触发子组件的 render，从而达到目的。shouldComponentUpdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。</p>
<ul>
<li>利用高阶组件</li>
</ul>
<p>在函数组件中，并没有 shouldComponentUpdate 这个生命周期，可以利用高阶组件，封装一个类似 PureComponet 的功能</p>
<ul>
<li>使用 React.memo</li>
</ul>
<p>React.memo 是 React 16.6 新的一个 API，用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似，但不同的是， React.memo只能用于函数组件。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">51. 在React中组件的this.state和setState有什么区别？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>this.state通常是用来初始化state的，this.setState是用来修改state值的。如果初始化了state之后再使用this.state，之前的state会被覆盖掉，如果使用this.setState，只会替换掉相应的state值。所以，如果想要修改state的值，就需要使用setState，而不能直接修改state，直接修改state之后页面是不会更新的。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">27. React 中 keys 的作用是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。</p>
</li>
<li><p>在 React 中渲染集合时，向每个重复的元素添加关键字对于帮助React跟踪元素与数据之间的关联非常重要。key 应该是唯一ID，最好是 UUID 或收集项中的其他唯一字符串：</p>
</li>
</ul>
<pre><code class="hljs language-react">
  &lt;ul&gt;
  {todos.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span>
    &lt;li key={todo.id}&gt;
      {todo.text}
    &lt;/li&gt;
  )};
  &lt;/ul&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">72. 为什么React组件中 return 一个对象而不是一个元素时会报错</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>因为对象不具备迭代接口，必须要时原型或者自己身上有[Symbol.iterator]属性才可以，而数组是有迭代接口的，所以可以直接迭代。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">69. React的Suspense组件和lazy函数是如何支持代码拆分的</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>React的Suspense组件和lazy函数是React支持代码拆分的重要工具。</p>
</li>
<li><p>lazy函数允许你动态地导入React组件，这意味着你可以将组件的代码分割到单独的文件中，并在需要时再进行加载。</p>
</li>
<li><p>Suspense组件则用于指定加载指示器（如加载动画或占位符），以便在组件加载完成之前向用户展示一些反馈。</p>
</li>
<li><p>通过结合使用lazy函数和Suspense组件，你可以实现按需加载组件，提高应用的初始加载速度和性能。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">61. 如何访问DOM元素？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>引用是使用 React.createRef() 或 useRef() 钩子创建的，并通过 ref 属性附加到 React 元素上。通过访问创建的引用，我们可以使用 ref.current 访问 DOM 元素。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">const</span> myRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myRef.<span class="hljs-property">current</span>); <span class="hljs-comment">// Accessing the DOM element</span>
  };

  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;input type=&quot;text&quot; ref={myRef} /&gt;
      &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;
    &lt;/div&gt;
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">62. 创建自定义钩子的规则是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>钩子名称以 &quot;use &quot;开头。</p>
</li>
<li><p>钩子只能从其他钩子或 React 元素中调用。</p>
</li>
<li><p>不要有条件地调用钩子。</p>
</li>
<li><p>将可重复使用的逻辑提取到自定义钩子中。</p>
</li>
<li><p>自定义钩子必须是纯函数。</p>
</li>
<li><p>自定义钩子可以返回值或其他钩子。</p>
</li>
<li><p>以描述性的方式命名自定义钩子。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">68. React18中引入的并发模式是什么，它带来了哪些改进</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>React18中引入的并发模式是一种新的渲染策略，它允许React在渲染过程中中断和恢复工作，以便更好地响应用户输入和其他高优先级任务。</p>
</li>
<li><p>通过并发模式，React可以更好地管理资源的分配和使用，提高应用的响应性和性能。</p>
</li>
<li><p>此外，并发模式还为React的未来扩展提供了基础，比如支持更复杂的动画和交互效果。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">24. react无状态组件和class类组件的区别？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>直观区别，函数组件代码量较少，相比类组件更加简洁</p>
</li>
<li><p>函数组件看似只是一个返回react元素的函数，其实体现的是无状态组件的思想，函数组件中没有this， 没有state，也没有生命周期，这就决定了函数组件都是展示性组件，接收props，渲染dom，而不关注其他逻辑</p>
</li>
<li><p>因为函数组件不需要考虑组件状态和组件生命周期方法中的各种比较校验，所以有很大的性能提升空间</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">78. 什么是 Redux Thunk？它解决了什么问题？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>Redux Thunk 是一个中间件，允许你在 action 创建函数中返回一个函数而不是一个 action 对象。这个返回的函数可以包含异步逻辑，并在适当的时候 dispatch 一个或多个 action。</p>
<p>解决问题：</p>
<p>异步操作：Redux Thunk 允许你处理异步操作，如 AJAX 请求，而不需要在 reducer 中处理异步逻辑。</p>
<p>复杂逻辑：可以处理复杂的业务逻辑，如条件 dispatch、多次 dispatch 等。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">import</span> { createStore, applyMiddleware } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;
<span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span>;

<span class="hljs-keyword">const</span> initialState = { <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span> };

<span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> = (<span class="hljs-params">state = initialState, action</span>) =&gt; {
  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;FETCH_DATA_SUCCESS&#x27;</span>:
      <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">data</span>: action.<span class="hljs-property">payload</span> };
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> state;
  }
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">async</span> (dispatch) =&gt; {
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/data&#x27;</span>);
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
  <span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_DATA_SUCCESS&#x27;</span>, <span class="hljs-attr">payload</span>: data });
};

<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducer, <span class="hljs-title function_">applyMiddleware</span>(thunk));

store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">fetchData</span>());
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">实现一个扇形</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li>用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：</li>
</ul>
<pre><code class="hljs language-css">div{
    <span class="hljs-attr">border</span>: 100px solid transparent;
    <span class="hljs-attr">width</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attr">height</span>: <span class="hljs-number">0</span>;
    border-<span class="hljs-attr">radius</span>: 100px;
    border-top-<span class="hljs-attr">color</span>: red;
}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">58. 什么是React调和？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li>调和是 React 的一种算法，用于区分一棵元素树和另一棵元素树，以确定需要替换的部分。
调和是我们过去所说的虚拟 DOM 背后的算法。其定义听起来是这样的：当您渲染 React 应用程序时，描述应用程序的元素树会在预留内存中生成。然后，这棵树就会被包含在呈现环境中，例如，在浏览器应用程序中，它会被转化为一组 DOM 操作。应用状态更新时，会生成新的元素树。新的树会与之前的树进行比较，以便准确计算和启用重新绘制更新后的应用程序所需的操作。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">35. Redux 有哪些优点？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>结果的可预测性 - 由于总是存在一个真实来源，即 store ，因此不存在如何将当前状态与动作和应用的其他部分同步的问题。</p>
</li>
<li><p>可维护性 - 由于没有直接接触 DOM，React 组件更容易进行单元测试和重用。</p>
</li>
<li><p>服务端渲染 - 你只需渲染应用一次，然后将结果发送到客户端。这对于 SEO 和快速首次渲染非常重要。</p>
</li>
<li><p>开发人员工具 - 从组件层次结构、当前状态和派生数据（如路由）到与时间旅行和编辑动作相关的任何内容，您都可以立即访问。</p>
</li>
<li><p>社区和生态系统 - React 拥有非常庞大且快速增长的生态系统，大量可重用的库和组件都可用于 React。</p>
</li>
<li><p>易于测试 - 由于应用的状态保存在 store 中，并且不直接与浏览器 DOM 交互，因此您的测试将更易于预测和复制。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">48. React中有使用过getDefaultProps吗？它有什么作用？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>通过实现组件的getDefaultProps，对属性设置默认值（ES5的写法）：</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">var</span> <span class="hljs-title class_">ShowTitle</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createClass</span>({
  <span class="hljs-attr">getDefaultProps</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">return</span>{
      title : <span class="hljs-string">&quot;React&quot;</span>
    }
  },
  render : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">return</span> &lt;h1&gt;{this.props.title}&lt;/h1&gt;
  }
});
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">75. shouldComponentUpdate有什么用？为什么它很重要？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>组件状态数据或者属性数据发生更新的时候，组件会进入存在期，视图会渲染更新。在生命周期方法 should ComponentUpdate中，允许选择退出某些组件（和它们的子组件）的和解过程。</p>
<p>和解的最终目标是根据新的状态，以最有效的方式更新用户界面。如果我们知道用户界面的某一部分不会改变，那么没有理由让 React弄清楚它是否应该更新渲染。通过在 shouldComponentUpdate方法中返回 false, React将让当前组件及其所有子组件保持与当前组件状态相同。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">26. React如何做路由监听</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><pre><code class="hljs language-react">
<span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>){ <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-property">router</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">listen</span>(<span class="hljs-function">(<span class="hljs-params">route</span>)=&gt;</span>{ <span class="hljs-keyword">if</span>(route.<span class="hljs-property">pathname</span>===<span class="hljs-string">&#x27;/xxx&#x27;</span>){ <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>); } }); } 
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">3. TCP与UDP区别是什么</h4><div class="head-re"><span class="head-score">8 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达</li>
<li><strong>1：</strong> UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；</li>
<li><strong>1：</strong> TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；</li>
<li><strong>1：</strong> UDP通信类似于学校广播，靠着广播播报直接进行通信。</li>
<li><strong>1：</strong> TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；</li>
<li><strong>1：</strong> TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。</li>
<li><strong>1：</strong> TCP首部开销（20字节）比UDP首部开销（8字节）要大</li>
<li><strong>1：</strong> UDP 的主机不需要维持复杂的连接状态表</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">32. 使用Hooks要遵守哪些原则？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>只在最顶层使用 Hook  不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。</p>
</li>
<li><p>只在 React 函数中调用 Hook</p>
</li>
</ul>
<p>不要在普通的 JavaScript 函数中调用 Hook。你可以：</p>
<ul>
<li><p>在 React 的函数组件中调用 Hook</p>
</li>
<li><p>在自定义 Hook 中调用其他 Hook</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">45. 对 React-Intl 的理解，它的工作原理？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>React-intl是雅虎的语言国际化开源项目FormatJS的一部分，通过其提供的组件和API可以与ReactJS绑定。</p>
<p>React-intl提供了两种使用方法，一种是引用React组件，另一种是直接调取API，官方更加推荐在React项目中使用前者，只有在无法使用React组件的地方，才应该调用框架提供的API。它提供了一系列的React组件，包括数字格式化、字符串格式化、日期格式化等。</p>
<p>在React-intl中，可以配置不同的语言包，他的工作原理就是根据需要，在语言包之间进行切换。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">50. React中的setState和replaceState的区别是什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>（1）setState() setState()用于设置状态对象，其语法如下：</p>
<pre><code class="hljs language-js">
<span class="hljs-title function_">setState</span>(object nextState[, <span class="hljs-keyword">function</span> callback])
</code></pre><ul>
<li><p>nextState，将要设置的新状态，该状态会和当前的state合并</p>
</li>
<li><p>callback，可选参数。回调函数。将在组件重新渲染后执行。在这个回调函数中你可以拿到更新后 state 的值</p>
</li>
</ul>
<p>合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。</p>
<p>（2）replaceState() replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。其语法如下</p>
<pre><code class="hljs language-js">
<span class="hljs-title function_">replaceState</span>(object nextState[, <span class="hljs-keyword">function</span> callback])
</code></pre><ul>
<li><p>nextState，将要设置的新状态，该状态会替换当前的state。</p>
</li>
<li><p>callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。</p>
</li>
</ul>
<p>总结： setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态。而replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">63. 如何不使用脚手架创建一个项目</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ol>
<li><p>yarn init 初始化package.json文件</p>
</li>
<li><p>安装react和react-dom</p>
</li>
<li><p>配置webpack</p>
</li>
<li><p>安装router</p>
</li>
<li><p>安装redux</p>
</li>
</ol>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Next.js中如何进行状态管理？</h4><div class="head-re"><span class="head-score">9 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> 局部状态管理<ul>
<li>useState：借助 React 的useState钩子可以管理组件内的简单状态。例如管理按钮的点击次数、输入框的值等。代码简洁，适合处理单一组件内独立的状态变化;</li>
<li>useReducer：当状态逻辑较为复杂，有多个子值或者下一个状态依赖于之前的状态时，使用useReducer更合适。它能把状态更新逻辑集中处理，让代码更易维护;</li>
</ul>
</li>
<li><strong>1：</strong> 全局状态管理（Context API）：React 自带的 Context API 可以在组件树中共享数据，避免了通过 props 层层传递数据的繁琐。在创建 Context 对象后，使用Provider包裹组件树，子组件通过useContext获取数据。不过在大型应用中，它的性能和可维护性可能会受到挑战。</li>
<li><strong>3：</strong> 第三方库<ul>
<li>Redux：是一个可预测的状态容器，适合管理大型应用的复杂状态。它采用单向数据流，所有状态集中存储在 store 中，通过 action 触发 reducer 来更新状态。结合react-redux库可以方便地在 React 组件中使用 Redux。</li>
<li>MobX：基于响应式编程的思想，使用observable定义可观察的状态，action修改状态，组件可以自动响应状态的变化。它的代码简洁，学习成本相对较低。</li>
<li>Zustand：轻量级的状态管理库，使用简单，没有复杂的样板代码。它通过创建 store 函数来定义状态和更新逻辑，组件可以直接订阅 store 的变化。</li>
</ul>
</li>
<li><strong>3：</strong> 服务器状态管理<ul>
<li>React Query：专注于处理服务器状态，如数据的获取、缓存、同步和更新等。它能自动处理加载状态、错误处理和数据的缓存，减少重复请求，提高应用性能。</li>
<li>SWR：也是用于数据获取的库，具有自动重新验证、聚焦重新验证、间隔重新验证等特性，能确保数据的实时性。</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">如何阻止事件冒泡，事件的默认行为？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p><strong>1：</strong> 阻止事件冒泡：event.stopPropagation();</p>
</li>
<li><p><strong>1：</strong> 阻止事件默认行为：event.preventDefault();</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">for in和for of的区别？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<ul>
<li><p><strong>1：</strong> 遍历目标不同</p>
<ul>
<li><p><strong>for in</strong>：遍历对象的<strong>可枚举属性</strong>（包括原型链属性），返回属性名（字符串类型）。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key); <span class="hljs-comment">// &#x27;a&#x27;, &#x27;b&#x27;</span>
</code></pre></li>
<li><p><strong>for of</strong>：遍历<strong>可迭代对象</strong>（数组/字符串/Set/Map等），返回属性值。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> val <span class="hljs-keyword">of</span> arr) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val); <span class="hljs-comment">// 1, 2, 3</span>
</code></pre></li>
</ul>
</li>
<li><p><strong>1：</strong> 底层机制差异</p>
<ul>
<li><strong>for in</strong>：基于对象的<code>Object.keys()</code> + 原型链搜索，会触发<code>[[Enumerate]]</code>内部方法。</li>
<li><strong>for of</strong>：基于可迭代协议（需实现<code>Symbol.iterator</code>方法），直接访问迭代器。</li>
</ul>
</li>
<li><p><strong>1：</strong> 典型应用场景</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐方案</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>对象属性遍历</td>
<td>for in</td>
<td>直接获取属性名</td>
</tr>
<tr>
<td>数组元素处理</td>
<td>for of</td>
<td>直接获取值，避免索引转换</td>
</tr>
<tr>
<td>字符串字符遍历</td>
<td>for of</td>
<td>支持Unicode代码点（如表情符号）</td>
</tr>
<tr>
<td>过滤原型链属性</td>
<td>for in</td>
<td>配合<code>hasOwnProperty</code>判断</td>
</tr>
</tbody></table>
</li>
</ul>
</details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">21. TypeScript中的映射类型是什么？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<ul>
<li><p><strong>2：</strong> 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。</p>
</li>
<li><p><strong>2：</strong> 示例：</p>
</li>
</ul>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// 原始接口</span>
interface <span class="hljs-title class_">Person</span> {
    <span class="hljs-attr">name</span>: string;
    <span class="hljs-attr">age</span>: number;
    <span class="hljs-attr">address</span>: string;
}

<span class="hljs-comment">// 将所有属性变为可选</span>
type <span class="hljs-title class_">PartialPerson</span> = <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">Person</span>&gt;;
<span class="hljs-comment">// 等价于:</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//    name?: string;</span>
<span class="hljs-comment">//    age?: number;</span>
<span class="hljs-comment">//    address?: string;</span>
<span class="hljs-comment">// }</span>

<span class="hljs-comment">// 将所有属性变为只读</span>
type <span class="hljs-title class_">ReadonlyPerson</span> = <span class="hljs-title class_">Readonly</span>&lt;<span class="hljs-title class_">Person</span>&gt;;
<span class="hljs-comment">// 等价于:</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//    readonly name: string;</span>
<span class="hljs-comment">//    readonly age: number;</span>
<span class="hljs-comment">//    readonly address: string;</span>
<span class="hljs-comment">// }</span>

<span class="hljs-comment">// 自定义映射类型</span>
type <span class="hljs-title class_">Nullable</span>&lt;T&gt; = {
    [P <span class="hljs-keyword">in</span> keyof T]: T[P] | <span class="hljs-literal">null</span>;
};

<span class="hljs-comment">// 使用自定义映射类型</span>
type <span class="hljs-title class_">NullablePerson</span> = <span class="hljs-title class_">Nullable</span>&lt;<span class="hljs-title class_">Person</span>&gt;;
<span class="hljs-comment">// 等价于:</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//    name: string | null;</span>
<span class="hljs-comment">//    age: number | null;</span>
<span class="hljs-comment">//    address: string | null;</span>
<span class="hljs-comment">// }</span>
</code></pre></details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">13. 请介绍一下require的模块加载机制？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>先计算模块路径</p>
</li>
<li><p>如果模块在缓存里面，取出缓存</p>
</li>
<li><p>如果是内置模块，取出内置模块</p>
</li>
<li><p>加载模块</p>
</li>
<li><p>输出模块的exports属性即可</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">请简要解释 Webpack 是什么，它的主要作用是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> Webpack 是一个模块打包工具，它可以将各种类型的模块（如 JS、CSS、图片等）打包成一个或多个文件。主要作用包括处理模块间的依赖关系、优化资源加载、提高项目的可维护性和性能。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 在开发模式下如何实现快速启动？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 利用 ES 模块的原生支持，通过浏览器直接加载模块文件，避免了传统打包工具的打包和重构过程。这种方式大大减少了启动时间，实现了快速的热更新和模块替换。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 中的 define 配置项有什么作用？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> define 配置项用于在编译时定义全局常量。它可以让你在代码中使用这些常量，并且在打包时会将这些常量替换为实际的值。这在处理一些环境特定的配置或常量时非常有用。
例如，在 vite.config.js 中：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">define</span>: {
    <span class="hljs-attr">__APP_VERSION__</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-string">&#x27;1.0.0&#x27;</span>),
    <span class="hljs-string">&#x27;process.env.NODE_ENV&#x27;</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-string">&#x27;development&#x27;</span>)
  }
});

<span class="hljs-comment">//在代码中就可以使用这些定义的常量：</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(__APP_VERSION__);
<span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&#x27;development&#x27;</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;当前是开发环境&#x27;</span>);
}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 与传统的 Webpack 打包工具有何不同？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 主要区别在于其开发模式的实现方式。Vite 在开发时不需要打包，而是直接通过浏览器加载模块，这使得启动速度更快。而 Webpack 在开发模式下仍然需要进行打包和热重载，这通常会更慢。此外，Vite 在生产构建时也采用了更现代的打包策略，如 Rollup，优化了打包输出。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 项目构建速度快的原因是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> Vite 利用了现代浏览器的原生 ES （ES Modules）模块支持，采用了按需加载和热更新技术。在开发过程中，它只加载和处理当前需要的模块，减少了不必要的代码编译和打包工作，并且通过快速
的热更新机制，使开发过程中能够迅速响应代码变化，提高了构建速度。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 如何支持 TypeScript？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是margin重叠问题？如何解决？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 垂直方向相邻块元素 margin 会合并，合并后取最大值。</li>
<li><strong>1：</strong> 解决方案<ul>
<li>触发 BFC（仅适用父子关系的margin重叠）</li>
<li>使用 padding 替代</li>
<li>将其中一个块元素改为行内块元素</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">24. HTTPS 是什么？具体流程</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>HTTPS 是在 HTTP 和 TCP 之间建立了一个安全层，HTTP 与 TCP 通信的时候，必须先进过一个安全层，对数据包进行加密，然后将加密后的数据包传送给 TCP，相应的 TCP 必须将数据包解密，才能传给上面的 HTTP。</p>
<p>浏览器传输一个 client_random 和加密方法列表，服务器收到后，传给浏览器一个 server_random、加密方法列表和数字证书（包含了公钥），然后浏览器对数字证书进行合法验证，如果验证通过，则生成一个 pre_random，然后用公钥加密传给服务器，服务器用 client_random、server_random 和 pre_random ，使用公钥加密生成 secret，然后之后的传输使用这个secret作为秘钥来进行数据的加解密。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">10. 什么是虚拟 DOM？它是如何工作的？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>虚拟 DOM 是一个轻量级的内存中的 DOM 树表示。React 使用虚拟 DOM 来提高性能，避免频繁的操作真实 DOM。</p>
</li>
<li><p>创建虚拟 DOM：React 在内存中创建一个虚拟 DOM 树。</p>
</li>
<li><p>Diff 算法：当状态改变时，React 会比较新的虚拟 DOM 和旧的虚拟 DOM，找出差异（即最小的变更集合）。</p>
</li>
<li><p>批量更新：React 将这些差异批量应用到真实 DOM，减少 DOM 操作次数，提高性能。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">CSS 中常用的布局方式有哪些？</h4><div class="head-re"><span class="head-score">9 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 普通流布局（Normal Flow）。即默认文档流布局，如：文章、博客；</li>
<li><strong>1：</strong> 浮动布局（Float）。适合元素环绕和多列布局，如：图文环绕、商品列表；</li>
<li><strong>1：</strong> 定位布局（Position）。适合指定位置布局，如：悬浮按钮、固定导航栏、弹窗；</li>
<li><strong>1：</strong> 弹性布局（Flex）。适合一维布局（横向或纵向），如：导航栏、卡片列表、响应式设计；</li>
<li><strong>1：</strong> 网格布局（Grid）。适合二维布局（横向和纵向），如：整体网页布局、栅格设计；</li>
<li><strong>1：</strong> 多列布局（Multi Column）。<code>.columns {column-count: 3;column-gap: 20px;}</code>;如：新闻排版、杂志排版；</li>
<li><strong>1：</strong> 自适应布局（Responsive）。@media，适合跨设备展示的布局，如：网页响应式设计、跨设备兼容布局；</li>
<li><strong>1：</strong> 容器查询布局（Responsive）。<code>container-type: inline-size;@container</code>，适合容器内布局，如：组件响应式设计、（低代码）组件化开发；</li>
<li><strong>1：</strong> 子网格布局（Subgrid）。适合容器内响应布局，如：复杂表单、复杂表格、复杂列表；</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">38. 怎么监听子组件内的错误？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><pre><code class="hljs language-js"><span class="hljs-comment">// 子组件</span>
<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Error&quot;</span>);

<span class="hljs-comment">//父组件</span>
<span class="hljs-keyword">import</span> { onErrorCaptured } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>

<span class="hljs-comment">// 监听到子组件错误，执行回调</span>
<span class="hljs-title function_">onErrorCaptured</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;error&#x27;</span>, err)
})
</code></pre></details></div><div class="content-scoring"><button class="export-excel customized">客制化</button><span>总得分：</span><span class="scoring-num">0</span><button class="export-excel">导出到Excel</button></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-04-07T02:13:36.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link prev" href="/mb-front-end-interview/src/training/training-level/W1.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>上一页</span><span class="title" data-v-1bcd8184>W1</span><!--]--></a></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-level/W3.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>W3</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"9IsXlCxp\",\"ing.md\":\"DEx_Hc6S\",\"readme.md\":\"DDRa-sHs\",\"src_guide_getting-started.md\":\"CL71JWFM\",\"src_guide_why.md\":\"BvHIQ29d\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"BokmUTWX\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"3Wwru424\",\"src_questions_computer-base_1_计算机硬件.md\":\"D9ntIop5\",\"src_questions_computer-base_2_计算机软件.md\":\"1EFyKC9f\",\"src_questions_computer-base_3_计算机网络.md\":\"C8RS2Mqz\",\"src_questions_computer-base_4_计算机编程.md\":\"Dir3CXmc\",\"src_questions_computer-base_5_计算机科学.md\":\"BTCW5YUI\",\"src_questions_computer-base_6_软件工程.md\":\"cmH5FSmz\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"hIOQG21W\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"CDM0yZEJ\",\"src_questions_data-structures-algorithms_1_算法.md\":\"ezcy1UHw\",\"src_questions_front-architect_1_前端架构.md\":\"BlTcSsq5\",\"src_questions_front-base_1_html.md\":\"DKu7GdHT\",\"src_questions_front-base_2_css.md\":\"BZ5_kkJW\",\"src_questions_front-base_3_javascript.md\":\"DhTsJI1R\",\"src_questions_front-base_4_typescript.md\":\"BYuwObrq\",\"src_questions_front-component_1_ui组件库.md\":\"kKacFWzv\",\"src_questions_front-component_2_业务组件库.md\":\"C9DBaQ9p\",\"src_questions_front-engineering_1_前端标准化.md\":\"CylB49a0\",\"src_questions_front-engineering_2_前端自动化.md\":\"CTgFekrK\",\"src_questions_front-engineering_3_webpack.md\":\"Cq0JY9i3\",\"src_questions_front-engineering_4_vite.md\":\"3Y3SC4KR\",\"src_questions_front-engineering_5_rollup.md\":\"Dc4coaJV\",\"src_questions_front-frame_1_react.md\":\"Nlj0kn5y\",\"src_questions_front-frame_2_vue.md\":\"C5o5nKbw\",\"src_questions_front-frame_3_next.md\":\"BSu_8BbM\",\"src_questions_front-frame_4_nuxt.md\":\"Dt8qSTaJ\",\"src_questions_front-frame_5_qiankun.md\":\"DaqtgiFk\",\"src_questions_front-newest_1_前端最前沿.md\":\"DFCokeFy\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"C2PRlOez\",\"src_questions_front-runtime_1_浏览器.md\":\"vFrDFvMb\",\"src_questions_front-runtime_2_nodejs.md\":\"BQYPG2Jf\",\"src_questions_front-safety_1_前端安全.md\":\"C8KfU3-Q\",\"src_questions_server_1_nest.md\":\"DCR3vJNi\",\"src_questions_server_2_mongodb.md\":\"C4f3evNV\",\"src_questions_server_3_mysql.md\":\"DS5uALSZ\",\"src_questions_server_4_nginx.md\":\"DGiMpf1Z\",\"src_questions_server_5_docker.md\":\"BBvUP3x7\",\"src_questions_server_6_kubernets.md\":\"iLBW23Fb\",\"src_questions_server_7_nacos.md\":\"sZY9vX9E\",\"src_questions_server_8_redis.md\":\"BlcQCjeU\",\"src_training_training-level_w1.md\":\"B1JchKhY\",\"src_training_training-level_w2.md\":\"BKzf8iR1\",\"src_training_training-level_w3.md\":\"bT9tGkXO\",\"src_training_training-level_w4.md\":\"YzHCFx_Q\",\"src_training_training-level_w5.md\":\"CpFeBIr-\",\"src_training_training-level_w6.md\":\"Ds_07UrR\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-level/w1\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"面试级别\",\"collapsed\":false,\"items\":[{\"text\":\"W1\",\"link\":\"/src/training/training-level/W1.md\"},{\"text\":\"W2\",\"link\":\"/src/training/training-level/W2.md\"},{\"text\":\"W3\",\"link\":\"/src/training/training-level/W3.md\"},{\"text\":\"W4\",\"link\":\"/src/training/training-level/W4.md\"},{\"text\":\"W5\",\"link\":\"/src/training/training-level/W5.md\"},{\"text\":\"W6\",\"link\":\"/src/training/training-level/W6.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"search\":{\"provider\":\"local\",\"options\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>