<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.DEQL0GKN.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.D2Wu_qoQ.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.cdqdtqqL.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.BZMTKtii.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/componentMarkdown.KAQz_zsC.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-senior_index.md.DmVOE8P3.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-primary/index.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>初级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-primary/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>中级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>高级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-senior/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>架构</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-architecture/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>专家</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-experts/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-senior_" data-v-e6f2a212><div><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">nuxt有哪些特性？</h4><div class="head-re"><span class="head-score">7 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 服务器端渲染(SSR)：Nuxt.js 支持服务器端渲染，可以提高网站的性能和搜索引擎优化。</li>
<li><strong>1：</strong> 自动路由：Nuxt.js 可以根据项目目录结构自动生成路由配置，减少手动配置的工作量。</li>
<li><strong>1：</strong> 预渲染：Nuxt.js 支持预渲染，可以在构建时生成静态 HTML 文件，提高网站的加载速度。</li>
<li><strong>1：</strong> 插件系统：Nuxt.js 提供了丰富的插件系统，可以方便地扩展功能和集成第三方库。</li>
<li><strong>1：</strong> 中间件：Nuxt.js 支持中间件，可以在路由处理之前或之后执行一些逻辑操作。</li>
<li><strong>1：</strong> 数据异步加载：Nuxt.js 支持在页面组件中异步加载数据，可以更好地控制数据的获取和展示。</li>
<li><strong>1：</strong> 静态文件服务：Nuxt.js 可以将静态文件直接发布到 CDN 或静态文件服务器，提高网站的访问速度。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">12. 如何处理浏览器兼容性问题？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 使用 CSS 前缀来兼容不同浏览器：例如，-webkit-，-moz-，-ms- 等。</li>
<li><strong>1：</strong> 使用 Autoprefixer 等工具自动添加前缀。</li>
<li><strong>1：</strong> 测试多个浏览器，确保关键功能正常</li>
<li><strong>1：</strong> 使用 CSS Reset 或 Normalize.css 来减少浏览器间的样式差异。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">26. 如何实现一个类型工具 `IsNever&lt;T&gt;`，用于判断一个类型 T 是否为 never 类型？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> 使用 <code>[T]</code> extends <code>[never]</code> 来判断，因为直接 T extends never 会有特殊处理，而包装成元组可以正确判断。</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-comment">// 答案</span>
type <span class="hljs-title class_">IsNever</span>&lt;T&gt; = [T] <span class="hljs-keyword">extends</span> [never]? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
<span class="hljs-comment">// 测试</span>
type <span class="hljs-title class_">Result1</span> = <span class="hljs-title class_">IsNever</span>&lt;never&gt;; <span class="hljs-comment">// true</span>
type <span class="hljs-title class_">Result2</span> = <span class="hljs-title class_">IsNever</span>&lt;string&gt;; <span class="hljs-comment">// false</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">指令集（Instruction Set）是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 指令集是CPU能够执行的指令的集合。不同的处理器架构会采用不同的指令集，包括x86、ARM、MIPS等。程序员需要了解所编写代码所运行的处理器架构和指令集，以确保代码的正确性和性能优化。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">前端如何防止点击劫持？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> 可以使用 X-Frame-Options 响应头来限制页面能否被嵌套在 iframe 中，例如设置为 DENY 禁止任何页面嵌套，或者 SAMEORIGIN 只允许同源页面嵌套。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">9. React中的Context是什么？如何使用？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> Context的创建和提供：</li>
</ul>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-string">&#x27;light&#x27;</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    &lt;ThemeContext.Provider value=&quot;dark&quot;&gt;
      &lt;ThemedButton /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}
</code></pre><ul>
<li><strong>1：</strong> 在类组件中使用Context：</li>
</ul>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThemedButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  <span class="hljs-keyword">static</span> contextType = <span class="hljs-title class_">ThemeContext</span>;
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> &lt;Button theme={this.context} /&gt;;
  }
}
</code></pre><ul>
<li><strong>1：</strong> 在函数组件中使用useContext：</li>
</ul>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemedButton</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> theme = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>);
  <span class="hljs-keyword">return</span> &lt;Button theme={theme} /&gt;;
}
</code></pre><ul>
<li><strong>1：</strong> Context的注意事项：<ul>
<li>避免过度使用Context</li>
<li>Context值变化会导致所有消费组件重新渲染</li>
<li>适合共享全局数据，如主题、用户信息等</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">52. 为什么会出现浮动? 什么时候需要清除浮动？清除浮动有哪些方式？优缺点是什么？你认为最好的是哪一种？为什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>出现浮动的原因：</p>
<p>浮动元素碰到包含它的边框或者浮动元素的边框停留。在CSS规范中，浮动定位不属于正常的页面流，而是独立定位的，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上。</p>
<p>关于css的定位机制：普通流，浮动，绝对定位（position：fixed是position：absolute的一个子类）。浮动的框可以左右移动，直到它的外边缘遇到包含框或者另一个浮动框的边缘，所以才说浮动定位不属于正常的页面流。文档中的普通流就会表现得和浮动框不存在一样，当浮动框高度超出包含框的时候，就会出现包含框不会自动伸缩高度类笔盒浮动元素。所以，只含有浮动元素的父容器在显示时不需要考虑子元素的位置，就造成显示父容器像空容器一样。</p>
<p>浮动带来的问题：</p>
<ul>
<li><p>父元素的高度无法被撑开，影响与父元素同级的元素</p>
</li>
<li><p>与浮动元素同级的非浮动元素（内联元素）会跟随其后</p>
</li>
<li><p>若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。</p>
</li>
</ul>
<p>清除浮动的方式：</p>
<ul>
<li><p>父级div定义height</p>
</li>
<li><p>最后一个浮动元素后加空div标签并设置属性 clear:both</p>
</li>
<li><p>包含浮动元素的父标签添加样式 overflow:hidden</p>
</li>
<li><p>父级div定义伪类:after 和 zoom</p>
</li>
<li><p>父级div定义伪类:after 和 display:table</p>
</li>
<li><p>父级div定义伪元素:after 和 content:” “</p>
</li>
</ul>
<p>最好的方式是给父元素添加overflow:hidden</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">54. 为什么 Vuex 的 mutation 中不能做异步操作？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。</p>
<p>每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">28. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。</p>
<p>离线的情况下，浏览器会直接使用离线存储的资源。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">25. 描述一下 TypeScript 中keyof操作符的作用和使用场景</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> keyof操作符用于获取类型的键类型。例如，<code>type K = keyof { a: number; b: string }</code>，K的类型就是<code>&#39;a&#39; | &#39;b&#39;</code>。</li>
<li><strong>1：</strong> 使用场景包括实现类型安全的对象访问，如根据键获取对象的值时确保键的类型正确。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">65. react函数组件和类组件的区别</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>编写形式：类组件的编写形式更加的冗余</p>
</li>
<li><p>状态管理：在hooks之前函数组件没有状态，在hooks提出之后，函数组件也可以维护自身的状态</p>
</li>
<li><p>生命周期：函数组件没有生命周期，这是因为生命周期钩子都来自于继承的React.Component，但是可以通过useEffect实现类似生命周期的效果</p>
</li>
<li><p>调用方式：函数组件通过执行函数调用，类组件通过实例化然后调用实例的render方法</p>
</li>
<li><p>获取渲染的值：函数组件存在闭包陷阱，类组件不存在（Props在 React中是不可变的所以它永远不会改变，但是 this 总是可变的，以便您可以在 render 和生命周期函数中读取新版本）</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">67. 说说React的Context API及其使用场景</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>React的Context API提供了一种在组件树中传递数据的方式，而无需手动逐层传递props。</p>
</li>
<li><p>它特别适用于跨多个层级共享数据或状态的情况，如主题、用户信息等。</p>
</li>
<li><p>使用Context API可以简化代码结构，避免prop drilling（属性穿透）的问题，并提高组件的复用性。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">45. 对 React-Intl 的理解，它的工作原理？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>React-intl是雅虎的语言国际化开源项目FormatJS的一部分，通过其提供的组件和API可以与ReactJS绑定。</p>
<p>React-intl提供了两种使用方法，一种是引用React组件，另一种是直接调取API，官方更加推荐在React项目中使用前者，只有在无法使用React组件的地方，才应该调用框架提供的API。它提供了一系列的React组件，包括数字格式化、字符串格式化、日期格式化等。</p>
<p>在React-intl中，可以配置不同的语言包，他的工作原理就是根据需要，在语言包之间进行切换。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">70. React18中引入了新的startTransition API，说说它的作用以及如何使用</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>React18中引入的startTransition API用于标记那些可能需要一段时间才能完成的更新（例如，从服务器获取数据）。</p>
</li>
<li><p>这个API允许React将UI的渲染划分为优先级较低的任务和优先级较高的任务。</p>
</li>
<li><p>通过调用startTransition并传入一个回调函数，我们可以告诉React：“这个更新可以稍后完成，先处理其他更紧急的事情。”</p>
</li>
<li><p>这使得React能够在等待数据加载时保持响应性，提供更好的用户体验。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">37. React 组件中怎么做事件代理？它的原理是什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>区别：</p>
<p>React基于Virtual DOM实现了一个SyntheticEvent层（合成事件层），定义的事件处理器会接收到一个合成事件对象的实例，它符合W3C标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。</p>
<p>在React底层，主要对合成事件做了两件事：</p>
<ul>
<li><p>事件委派： React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。</p>
</li>
<li><p>自动绑定： React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">23. 说说对Fiber架构的理解？解决了什么问题？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>在react中，主要做了以下的操作：</p>
<ul>
<li><strong>1：</strong> 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务</li>
<li><strong>1：</strong> 增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行</li>
<li><strong>1：</strong> dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行</li>
<li><strong>1：</strong> Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行，即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">28. React diff 原理</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>把树形结构按照层级分解，只比较同级元素。</p>
</li>
<li><p>列表结构的每个单元添加唯一的 key 属性，方便比较。</p>
</li>
<li><p>React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）</p>
</li>
<li><p>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.</p>
</li>
<li><p>选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">26. React如何做路由监听</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><pre><code class="hljs language-react">
<span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>){ <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-property">router</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">listen</span>(<span class="hljs-function">(<span class="hljs-params">route</span>)=&gt;</span>{ <span class="hljs-keyword">if</span>(route.<span class="hljs-property">pathname</span>===<span class="hljs-string">&#x27;/xxx&#x27;</span>){ <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>); } }); } 
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">55. Redux 实现了哪种模式？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Redux 实现了Flux 模式，它是应用程序的可预测状态管理模式。它通过引入单向数据流和应用程序状态的集中存储来帮助管理应用程序的状态。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">31. 为什么说React中的props是只读的？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>保证react的单向数据流的设计模式，使状态更可预测。如果允许自组件修改，那么一个父组件将状态传递给好几个子组件，这几个子组件随意修改，就完全不可预测，不知道在什么地方修改了状态，所以我们必须像纯函数一样保护 props 不被修改</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">36. React的事件和普通的HTML事件有什么不同？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>区别：</p>
<ul>
<li><p>对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；</p>
</li>
<li><p>对于事件函数处理语法，原生事件为字符串，react 事件为函数；</p>
</li>
<li><p>react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为。</p>
</li>
</ul>
<p>合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象，其优点如下：</p>
<ul>
<li><p>兼容所有浏览器，更好的跨平台；</p>
</li>
<li><p>将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。</p>
</li>
<li><p>方便 react 统一管理和事务机制。</p>
</li>
</ul>
<p>事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">TCP与UDP区别是什么</h4><div class="head-re"><span class="head-score">8 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达</li>
<li><strong>1：</strong> UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；</li>
<li><strong>1：</strong> TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；</li>
<li><strong>1：</strong> UDP通信类似于学校广播，靠着广播播报直接进行通信。</li>
<li><strong>1：</strong> TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；</li>
<li><strong>1：</strong> TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。</li>
<li><strong>1：</strong> TCP首部开销（20字节）比UDP首部开销（8字节）要大</li>
<li><strong>1：</strong> UDP 的主机不需要维持复杂的连接状态表</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">44. 在React中如何避免不必要的render？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>React 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。这里提下优化的点</p>
<ul>
<li>shouldComponentUpdate 和 PureComponent</li>
</ul>
<p>在 React 类组件中，可以利用 shouldComponentUpdate或者 PureComponent 来减少因父组件更新而触发子组件的 render，从而达到目的。shouldComponentUpdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。</p>
<ul>
<li>利用高阶组件</li>
</ul>
<p>在函数组件中，并没有 shouldComponentUpdate 这个生命周期，可以利用高阶组件，封装一个类似 PureComponet 的功能</p>
<ul>
<li>使用 React.memo</li>
</ul>
<p>React.memo 是 React 16.6 新的一个 API，用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似，但不同的是， React.memo只能用于函数组件。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">49. React中setState的第二个参数作用是什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>setState 的第二个参数是一个可选的回调函数。这个回调函数将在组件重新渲染后执行。等价于在 componentDidUpdate 生命周期内执行。通常建议使用 componentDidUpdate 来代替此方式。在这个回调函数中你可以拿到更新后 state 的值：</p>
<pre><code class="hljs language-js">
<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({
    <span class="hljs-attr">key1</span>: newState1,
    <span class="hljs-attr">key2</span>: newState2,
    ...
}, callback) <span class="hljs-comment">// 第二个参数是 state 更新完成后的回调函数</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">73. React可以在哪个生命周期访问DOM，在哪个时机访问Ref？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>访问 DOM： 在 React 中，通常应该遈避免直接操作 DOM，因为 React 采用 Virtual DOM 的方式管理页面渲染。但是，如果确实需要访问真实的 DOM 元素，可以在组件的以下生命周期方法中进行</p>
<p>componentDidMount()：在组件挂载后立即调用。可以在这个生命周期方法中访问和操作 DOM 元素，执行初始化操作等。</p>
<p>componentDidUpdate(prevProps, prevState)：在组件更新后被调用。可以在此方法中根据更新后的 props 或 state 来访问或操作 DOM 元素。</p>
<p>访问 Ref： Ref 是用于访问真实 DOM 节点或 React 组件实例的一种方式。在 React 中，可以在以下时机访问 Ref：</p>
<p>使用 Ref：可以在componentDidMount()、componentDidUpdate() 或事件处理程序中访问 Ref。通过 Ref 可以获取到对应的 DOM 元素或组件实例。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">40. React.createClass和extends Component的区别有哪些？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>语法区别</p>
<ul>
<li><p>createClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。</p>
</li>
<li><p>createClass方式的方法定义使用逗号，隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6 class的语法规范。</p>
</li>
</ul>
<p>propType 和 getDefaultProps</p>
<ul>
<li><p>React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.</p>
</li>
<li><p>React.Component：通过设置两个属性propTypes和defaultProps</p>
</li>
</ul>
<p>状态的区别</p>
<ul>
<li><p>React.createClass：通过getInitialState()方法返回一个包含初始值的对象</p>
</li>
<li><p>React.Component：通过constructor构造函数设置初始状态</p>
</li>
</ul>
<p>this.state</p>
<ul>
<li><p>React.createClass：需要显示的调用this.setState()方法</p>
</li>
<li><p>React.Component：不需要调用，直接this.state获取</p>
</li>
</ul>
<p>Mixins</p>
<ul>
<li><p>React.createClass：通过mixins属性混合进来</p>
</li>
<li><p>React.Component：通过引入React Mixin</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">60. 如何跟踪功能组件中对象字段的变化？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>需要使用 useEffect 钩子，并将对象的字段作为依赖数组传递。</p>
<pre><code class="hljs language-js">
<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Changed!&#x27;</span>)
}, [obj.<span class="hljs-property">someField</span>])
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">63. 如何不使用脚手架创建一个项目</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ol>
<li><p>yarn init 初始化package.json文件</p>
</li>
<li><p>安装react和react-dom</p>
</li>
<li><p>配置webpack</p>
</li>
<li><p>安装router</p>
</li>
<li><p>安装redux</p>
</li>
</ol>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">46. 为什么React并不推荐优先考虑使用Context？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。</p>
<p>尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context</p>
<p>对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。</p>
<p>context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">41. 对componentWillReceiveProps 的理解</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>该方法当props发生变化时执行，初始化render时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用this.setState()来更新你的组件状态，旧的属性还是可以通过this.props来获取,这里调用更新状态是安全的，并不会触发额外的render调用。</p>
<p>使用好处： 在这个生命周期中，可以在子组件的render函数执行前获取新的props，从而更新子组件自己的state。 可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。</p>
<p>componentWillReceiveProps在初始化render的时候不会执行，它会在Component接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">协商缓存和强缓存的区别</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> 强缓存<ul>
<li>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</li>
<li>设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。</li>
</ul>
</li>
<li><strong>2：</strong> 协商缓存<ul>
<li>如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。</li>
<li>设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">5. webpack proxy是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> webpack proxy，是 webpack 提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器，其目的是为了便于开发者在开发模式下解决跨域问题(浏览器安全策略限制)</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">14. webpack常见的提升构建速度的方法</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> 常见的有一下几种：</li>
</ul>
<blockquote>
<p>优化 loader 配置<br>合理使用 resolve.extensions<br>优化 resolve.modules<br>优化 resolve.alias<br>使用 DLLPlugin 插件<br>使用 cache-loader<br>terser 启动多线程<br>合理使用 sourceMap</p>
</blockquote>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 如何支持 TypeScript？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">WebAssembly 的工作原理是什么？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 编写源代码：使用支持 WebAssembly 的语言（如 C、C++ 或 Rust）编写源代码。</li>
<li><strong>1：</strong> 编译为 WebAssembly 模块：将源代码编译为 .wasm 文件，这是 WebAssembly 的二进制格式。</li>
<li><strong>1：</strong> 在浏览器中加载和运行：通过 JavaScript 在浏览器中加载 .wasm 文件并实例化。</li>
<li><strong>1：</strong> 执行 WebAssembly 函数：JavaScript 调用 WebAssembly 函数，执行高性能计算任务。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">38. Webpack 的核心概念有哪些？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 入口（Entry）：指示 Webpack 从哪个模块开始打包，可配置单个或多个入口。</li>
<li><strong>1：</strong> 输出（Output）：告诉 Webpack 打包后的文件存放在哪里，以及如何命名。</li>
<li><strong>1：</strong> loader：用于处理不同类型的文件，将它们转换为 Webpack 能够处理的模块。例如，<code>css-loader</code> 用于处理 CSS 文件，<code>babel-loader</code> 用于将 ES6+ 代码转
换为向后兼容的 JavaScript 代码。</li>
<li><strong>1：</strong> 插件（Plugin）：用于执行更广泛的任务，如代码压缩、分割代码、生成 HTML 文件等。常见的插件有 HtmlWebpackPlugin、MiniCssExtractPlugin 等。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">6. webpack 中提供服务器的工具是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> webpack 中提供服务器的工具为 webpack-dev-server</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">2. webpack 中如何配置开启热更新？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong></li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack&quot;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">devServer</span>: {
    <span class="hljs-comment">// HMR</span>
    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-comment">// hotOnly: true</span>
  },
};
</code></pre></details></div><div class="content-scoring"><span>总得分：</span><span class="scoring-num">0</span><button class="export-excel">导出到Excel</button></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-02-07T10:22:06.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link prev" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>上一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-architecture/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"67oPUNm0\",\"ing.md\":\"B1bdgE1J\",\"readme.md\":\"Byfv3CVo\",\"src_guide_getting-started.md\":\"zW1zakJi\",\"src_guide_why.md\":\"D2x4ud5w\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"CNJOJ2_8\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"Dt66jo8r\",\"src_questions_computer-base_1_计算机硬件.md\":\"C4Oz8Lb9\",\"src_questions_computer-base_2_计算机软件.md\":\"CF1aUnc6\",\"src_questions_computer-base_3_计算机网络.md\":\"DBideFga\",\"src_questions_computer-base_4_计算机编程.md\":\"BVJgAmGm\",\"src_questions_computer-base_5_计算机科学.md\":\"DWeV7UIw\",\"src_questions_computer-base_6_软件工程.md\":\"DNQN1yEz\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"BY6WVDnG\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"B_0bvJA3\",\"src_questions_data-structures-algorithms_1_算法.md\":\"D8SrYBaL\",\"src_questions_front-architect_1_前端架构.md\":\"Dbgj-82H\",\"src_questions_front-base_1_html.md\":\"DMB_hQ8I\",\"src_questions_front-base_2_css.md\":\"wvegWmTo\",\"src_questions_front-base_3_javascript.md\":\"BJN_QHKI\",\"src_questions_front-base_4_typescript.md\":\"C2tEm5ek\",\"src_questions_front-component_1_ui组件库.md\":\"DdkXqeGF\",\"src_questions_front-component_2_业务组件库.md\":\"nlmFiq-7\",\"src_questions_front-engineering_1_前端标准化.md\":\"CcVdD_4-\",\"src_questions_front-engineering_2_前端自动化.md\":\"C_ObcZUk\",\"src_questions_front-engineering_3_webpack.md\":\"C_UQqPoj\",\"src_questions_front-engineering_4_vite.md\":\"JeGPZMNA\",\"src_questions_front-engineering_5_rollup.md\":\"C2M1uYps\",\"src_questions_front-frame_1_react.md\":\"BnVer4CL\",\"src_questions_front-frame_2_vue.md\":\"uIqyO-Oo\",\"src_questions_front-frame_3_next.md\":\"DtEaYuR9\",\"src_questions_front-frame_4_nuxt.md\":\"C1WrCg8L\",\"src_questions_front-frame_5_qiankun.md\":\"BwZ10FDj\",\"src_questions_front-newest_1_前端最前沿.md\":\"CkOPJbom\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"Y1YYN3Ud\",\"src_questions_front-runtime_1_浏览器.md\":\"CaS6fm6h\",\"src_questions_front-runtime_2_nodejs.md\":\"C6XqsZ1A\",\"src_questions_front-safety_1_前端安全.md\":\"C6DLHJ43\",\"src_questions_server_1_nest.md\":\"BOMSNSSC\",\"src_questions_server_2_mongodb.md\":\"NWpo9pl3\",\"src_questions_server_3_mysql.md\":\"DpJwRIli\",\"src_questions_server_4_nginx.md\":\"qNFFGs-P\",\"src_questions_server_5_docker.md\":\"BOgiSHaM\",\"src_questions_server_6_kubernets.md\":\"doe--BqB\",\"src_questions_server_7_nacos.md\":\"C4GksE-T\",\"src_questions_server_8_redis.md\":\"BuBc2S9c\",\"src_training_training-architecture_index.md\":\"RvkubvPc\",\"src_training_training-experts_index.md\":\"C3Bg7WJV\",\"src_training_training-intermediate_index.md\":\"DrMfWgHU\",\"src_training_training-primary_index.md\":\"BrcGar2Z\",\"src_training_training-senior_index.md\":\"DmVOE8P3\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-primary/index\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"初级\",\"collapsed\":false,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-primary/index.md\"}]},{\"text\":\"中级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-intermediate/index.md\"}]},{\"text\":\"高级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-senior/index.md\"}]},{\"text\":\"架构\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-architecture/index.md\"}]},{\"text\":\"专家\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-experts/index.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"search\":{\"provider\":\"local\",\"options\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>