import{_ as a,c as o,a0 as r,o as t}from"./chunks/framework.HNGcFqhl.js";const w=JSON.parse('{"title":"Vue","description":"","frontmatter":{},"headers":[],"relativePath":"src/questions/front-frame/2_Vue.md","filePath":"src/questions/front-frame/2_Vue.md","lastUpdated":1734944096000}'),i={name:"src/questions/front-frame/2_Vue.md"};function d(c,e,l,n,h,s){return t(),o("div",null,e[0]||(e[0]=[r('<h1 id="vue" tabindex="-1">Vue <a class="header-anchor" href="#vue" aria-label="Permalink to &quot;Vue&quot;">​</a></h1><h2 id="vue3和vue2的区别" tabindex="-1">vue3和vue2的区别 <a class="header-anchor" href="#vue3和vue2的区别" aria-label="Permalink to &quot;vue3和vue2的区别&quot;">​</a></h2><h4 id="类型-基础" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-11-分" tabindex="-1">解答（11 分） <a class="header-anchor" href="#解答-11-分" aria-label="Permalink to &quot;解答（11 分）&quot;">​</a></h4><ul><li><strong>1：</strong> 源码组织方式变化：使用 TS 重写</li><li><strong>1：</strong> 支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）</li><li><strong>1：</strong> 响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化</li><li><strong>1：</strong> 编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容</li><li><strong>1：</strong> 打包体积优化：移除了一些不常用的api（inline-template、filter）</li><li><strong>1：</strong> 生命周期的变化：使用setup代替了之前的beforeCreate和created</li><li><strong>1：</strong> Vue3 的 template 模板支持多个根标签</li><li><strong>1：</strong> Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore</li><li><strong>1：</strong> Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例</li><li><strong>1：</strong> Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props</li><li><strong>1：</strong> 父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下</li></ul><h2 id="watch-和-watcheffect-的区别" tabindex="-1">watch 和 watchEffect 的区别？ <a class="header-anchor" href="#watch-和-watcheffect-的区别" aria-label="Permalink to &quot;watch 和 watchEffect 的区别？&quot;">​</a></h2><h4 id="类型-基础-1" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-1" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-1" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-1" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3分" tabindex="-1">解答（3分） <a class="header-anchor" href="#解答-3分" aria-label="Permalink to &quot;解答（3分）&quot;">​</a></h4><ul><li><strong>1：</strong> watch ：既要指明监视的数据源，也要指明监视的回调。</li><li><strong>1：</strong> watchEffect 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。</li><li><strong>1：</strong> watch 可以访问改变之前和之后的值，watchEffect 只能获取改变后的值。</li></ul><h2 id="在-vue2-x-中如何检测数组的变化" tabindex="-1">在 Vue2.x 中如何检测数组的变化？ <a class="header-anchor" href="#在-vue2-x-中如何检测数组的变化" aria-label="Permalink to &quot;在 Vue2.x 中如何检测数组的变化？&quot;">​</a></h2><h4 id="类型-基础-2" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-2" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-2" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-2" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-1分" tabindex="-1">解答（1分） <a class="header-anchor" href="#解答-1分" aria-label="Permalink to &quot;解答（1分）&quot;">​</a></h4><ul><li><strong>1：</strong> 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</li></ul><h2 id="在-v-if-与-v-show-的区别" tabindex="-1">在 v-if 与 v-show 的区别？ <a class="header-anchor" href="#在-v-if-与-v-show-的区别" aria-label="Permalink to &quot;在 v-if 与 v-show 的区别？&quot;">​</a></h2><h4 id="类型-基础-3" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-3" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-3" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-3" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-1分-1" tabindex="-1">解答（1分） <a class="header-anchor" href="#解答-1分-1" aria-label="Permalink to &quot;解答（1分）&quot;">​</a></h4><ul><li><strong>1：</strong> 当条件不成立时，v-if不会渲染DOM元素，v-show操作的是样式(display)，切换当前DOM的显示和隐藏。</li></ul><h2 id="v-model-双向绑定的原理是什么" tabindex="-1">v-model 双向绑定的原理是什么？ <a class="header-anchor" href="#v-model-双向绑定的原理是什么" aria-label="Permalink to &quot;v-model 双向绑定的原理是什么？&quot;">​</a></h2><h4 id="类型-基础-4" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-4" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-4" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-4" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-1分-2" tabindex="-1">解答（1分） <a class="header-anchor" href="#解答-1分-2" aria-label="Permalink to &quot;解答（1分）&quot;">​</a></h4><ul><li><strong>1：</strong> v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性 。</li></ul><h2 id="在-v-if-和-v-for-的优先级哪个高" tabindex="-1">在 v-if 和 v-for 的优先级哪个高？ <a class="header-anchor" href="#在-v-if-和-v-for-的优先级哪个高" aria-label="Permalink to &quot;在  v-if 和 v-for 的优先级哪个高？&quot;">​</a></h2><h4 id="类型-基础-5" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-5" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-5" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-5" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-1分-3" tabindex="-1">解答（1分） <a class="header-anchor" href="#解答-1分-3" aria-label="Permalink to &quot;解答（1分）&quot;">​</a></h4><ul><li><strong>1：</strong> 在 vue2 中 v-for 的优先级更高，但是在 vue3 中优先级改变了。v-if 的优先级更高。</li></ul><h2 id="ref与reactive的区别" tabindex="-1">ref与reactive的区别？ <a class="header-anchor" href="#ref与reactive的区别" aria-label="Permalink to &quot;ref与reactive的区别？&quot;">​</a></h2><h4 id="类型-基础-6" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-6" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-6" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-6" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-6分" tabindex="-1">解答（6分） <a class="header-anchor" href="#解答-6分" aria-label="Permalink to &quot;解答（6分）&quot;">​</a></h4><ul><li><strong>1：</strong> ref与reactive 是 Vue3 新推出的主要 API 之一，它们主要用于响应式数据的创建。</li><li><strong>1：</strong> ref 函数创建的响应式数据，在模板中可以直接被使用，在 JS 中需要通过 .value 的形式才能使用。</li><li><strong>1：</strong> ref 函数可以接收原始数据类型与引用数据类型。</li><li><strong>1：</strong> reactive 函数只能接收引用数据类型。</li><li><strong>1：</strong> ref 底层还是使用 reactive 来做，ref 是在 reactive 上在进行了封装，增强了其能力，使它支持了对原始数据类型的处理。</li><li><strong>1：</strong> 在 Vue3 中 reactive 能做的，ref 也能做，reactive 不能做的，ref 也能做。</li></ul>',36)]))}const f=a(i,[["render",d]]);export{w as __pageData,f as default};
